================================================================================
API PROTOCOL DOCUMENTATION
Detailed Request Processing Flow and Protocol Mapping
================================================================================

Date: 2025-01-XX
Author: IDSS Backend Team

This document describes:
1. How requests map to existing protocols (MCP, UCP, Tool)
2. How requests are processed step-by-step
3. Data flow through Redis, PostgreSQL, Neo4j
4. Response format and structure

================================================================================
0. QUICK EXAMPLES (REQUEST → MCP RESPONSE → AGENT MESSAGE)
================================================================================

Use these upfront examples to show concrete MCP capabilities and how the AI
agent should interpret responses.

Example A: Add this specific product to cart
--------------------------------------------
MCP Request (POST /api/add-to-cart)
{
  "cart_id": "cart-001",
  "product_id": "laptop-001",
  "qty": 1
}

MCP Response (envelope)
{
  "status": "OK",
  "data": {
    "cart_id": "cart-001",
    "items": [{"product_id": "laptop-001", "quantity": 1, "price_cents": 149999}],
    "item_count": 1,
    "total_cents": 149999,
    "currency": "USD"
  },
  "trace": {"request_id": "..."},
  "version": {"catalog_version": "1.0.0"}
}

Agent-facing message (example)
"Added Gaming Laptop RTX 4060 to your cart. Total: $1499.99."

Example B: Get a specific product
---------------------------------
MCP Request (POST /api/get-product)
{
  "product_id": "laptop-001",
  "fields": ["name", "price_cents", "available_qty"]
}

MCP Response (envelope)
{
  "status": "OK",
  "data": {"product_id": "laptop-001", "name": "Gaming Laptop RTX 4060", "price_cents": 149999},
  "trace": {"request_id": "..."},
  "version": {"catalog_version": "1.0.0"}
}

Agent-facing message (example)
"Gaming Laptop RTX 4060 is $1499.99 and currently in stock."

Example C: Search then add to cart (IDs-only execution)
-------------------------------------------------------
1) POST /api/search-products → choose a product_id
2) POST /api/add-to-cart with that product_id
3) Agent summarizes the action to the user

Example D: /chat interview flow (laptops/books)
-----------------------------------------------
Chat Request 1 (POST /chat)
{
  "message": "laptop",
  "session_id": "session-123"
}

Chat Response 1
{
  "response_type": "question",
  "message": "What will you primarily use the laptop for?",
  "session_id": "session-123",
  "quick_replies": ["Gaming", "Work/Business", "School/Student", "Creative Work"],
  "domain": "laptops",
  "filters": {"category": "Electronics", "product_type": "laptop"},
  "question_count": 1
}

Chat Request 2
{
  "message": "School",
  "session_id": "session-123"
}

Chat Response 2
{
  "response_type": "question",
  "message": "Do you have a preferred brand?",
  "session_id": "session-123",
  "quick_replies": ["Apple (Mac)", "Dell", "Lenovo", "HP"],
  "domain": "laptops",
  "filters": {"category": "Electronics", "product_type": "laptop", "subcategory": "School", "use_case": "School"},
  "question_count": 2
}

Chat Request 3
{
  "message": "Dell",
  "session_id": "session-123"
}

Chat Response 3
{
  "response_type": "question",
  "message": "What is your budget for the laptop?",
  "session_id": "session-123",
  "quick_replies": ["Under $500", "$500-$1000", "$1000-$2000", "Over $2000"],
  "domain": "laptops",
  "filters": {"category": "Electronics", "product_type": "laptop", "subcategory": "School", "use_case": "School", "brand": "Dell"},
  "question_count": 3
}

Chat Request 4
{
  "message": "$1000-$2000",
  "session_id": "session-123"
}

Chat Response 4 (recommendations)
{
  "response_type": "recommendations",
  "message": "Here are top laptops recommendations:",
  "session_id": "session-123",
  "domain": "laptops",
  "recommendations": [[{"@id": "prod-001", "vehicle": {"make": "Dell", "model": "Inspiron 14"}}]],
  "bucket_labels": ["Budget-Friendly ($999-$1299)"],
  "filters": {
    "category": "Electronics",
    "product_type": "laptop",
    "subcategory": "School",
    "use_case": "School",
    "brand": "Dell",
    "price_min_cents": 100000,
    "price_max_cents": 200000
  },
  "question_count": 3
}

Example E: /chat interview flow (books)
---------------------------------------
Chat Request 1 (POST /chat)
{
  "message": "books",
  "session_id": "session-456"
}

Chat Response 1
{
  "response_type": "question",
  "message": "What genre of book are you in the mood for?",
  "session_id": "session-456",
  "quick_replies": ["Fiction", "Mystery", "Sci-Fi", "Non-Fiction", "Self-Help"],
  "domain": "books",
  "filters": {"category": "Books", "product_type": "book"},
  "question_count": 1
}

Chat Request 2
{
  "message": "Mystery",
  "session_id": "session-456"
}

Chat Response 2
{
  "response_type": "question",
  "message": "Do you have a price limit?",
  "session_id": "session-456",
  "quick_replies": ["Under $15", "$15-$30", "Any price"],
  "domain": "books",
  "filters": {"category": "Books", "product_type": "book", "subcategory": "Mystery", "genre": "Mystery"},
  "question_count": 2
}

Chat Request 3
{
  "message": "$15-$30",
  "session_id": "session-456"
}

Chat Response 3 (recommendations)
{
  "response_type": "recommendations",
  "message": "Here are top books recommendations:",
  "session_id": "session-456",
  "domain": "books",
  "recommendations": [[{"@id": "book-101", "vehicle": {"make": "Publisher", "model": "Mystery Title"}}]],
  "bucket_labels": ["Budget-Friendly ($15-$30)"],
  "filters": {
    "category": "Books",
    "product_type": "book",
    "subcategory": "Mystery",
    "genre": "Mystery",
    "price_min_cents": 1500,
    "price_max_cents": 3000
  },
  "question_count": 2
}

================================================================================
1. GET PRODUCT ENDPOINT
================================================================================

ENDPOINT: /api/get-product
PROTOCOL: MCP (Model Context Protocol)

PROTOCOL MAPPING:
-----------------
- MCP Protocol: POST /api/get-product
  Request Schema: GetProductRequest
  {
    "product_id": "string (required)",
    "fields": ["string"] (optional, field projection)
  }

- UCP Protocol: POST /ucp/get-product
  Request Schema: UCPGetProductRequest
  Maps to: GetProductRequest
  Conversion: ucp_get_product() -> get_product()

- Tool Protocol: POST /tools/execute
  {
    "tool_name": "get_product",
    "parameters": {
      "product_id": "string",
      "fields": ["string"]
    }
  }

REQUEST PROCESSING FLOW:
------------------------
Step 1: Request Received
  - Validate product_id (required field)
  - Generate request_id for tracing
  - Log protocol mapping (MCP/UCP/Tool)

Step 2: Redis Cache Lookup (Cache-Aside Pattern)
  - Check cache keys:
    * mcp:prod_summary:{product_id} (TTL: 300s / 5 min)
    * mcp:price:{product_id} (TTL: 60s / 1 min)
    * mcp:inventory:{product_id} (TTL: 30s / 30 sec)
  - If all three cached: Return from Redis (cache hit)
  - If any missing: Proceed to PostgreSQL (cache miss)

Step 3: PostgreSQL Query (Authoritative Source)
  - Query: SELECT * FROM products WHERE product_id = ?
  - Join with prices table (product_id)
  - Join with inventory table (product_id)
  - If not found: Return NOT_FOUND status

Step 4: Build ProductDetail Object
  - Extract from PostgreSQL:
    * product_id, name, description, category, brand
    * price_cents, currency (from prices table)
    * available_qty (from inventory table)
    * source, color, scraped_from_url, reviews
    * created_at, updated_at

Step 5: Update Redis Cache
  - Set product_summary (TTL: 5 min)
  - Set price (TTL: 1 min)
  - Set inventory (TTL: 30 sec)
  - Cache-aside: Write-through on cache miss

Step 6: Apply Field Projection (if requested)
  - Filter ProductDetail to only requested fields
  - Reduces response size for efficiency

Step 7: Build MCP Response Envelope
  - status: ResponseStatus enum (OK, NOT_FOUND, etc.)
  - data: ProductDetail object (or None)
  - constraints: List[ConstraintDetail] (empty if OK)
  - trace: RequestTrace (timings, sources, cache_hit)
  - version: VersionInfo (catalog_version, updated_at)

DATA SOURCES (Priority Order):
-------------------------------
1. Redis (cache, fast, 1-5 min TTL)
2. PostgreSQL (authoritative, persistent)
3. Neo4j (relationships, optional, if enabled)

RESPONSE FORMAT:
----------------
{
  "status": "OK" | "NOT_FOUND" | "ERROR",
  "data": {
    "product_id": "string",
    "name": "string",
    "description": "string",
    "category": "string",
    "brand": "string",
    "price_cents": 0,
    "currency": "USD",
    "available_qty": 0,
    "source": "string",
    "color": "string",
    "scraped_from_url": "string",
    "reviews": "string",
    "created_at": "ISO datetime",
    "updated_at": "ISO datetime"
  },
  "constraints": [],
  "trace": {
    "request_id": "uuid",
    "cache_hit": true/false,
    "timings_ms": {
      "cache": 0.0,
      "db": 0.0,
      "total": 0.0
    },
    "sources": ["redis"] | ["postgres"]
  },
  "version": {
    "catalog_version": "string",
    "updated_at": "ISO datetime"
  }
}

================================================================================
2. SEARCH PRODUCTS ENDPOINT
================================================================================

ENDPOINT: /api/search-products
PROTOCOL: MCP (Model Context Protocol)

PROTOCOL MAPPING:
-----------------
- MCP Protocol: POST /api/search-products
  Request Schema: SearchProductsRequest
  {
    "query": "string",
    "filters": {
      "category": "string",
      "brand": "string",
      "price_min_cents": 0,
      "price_max_cents": 0,
      "product_type": "string",
      "gpu_vendor": "string"
    },
    "limit": 10,
    "cursor": "string" (optional, pagination)
  }

- UCP Protocol: POST /ucp/search
  Request Schema: UCPSearchRequest
  Maps to: SearchProductsRequest
  Conversion: ucp_search() -> search_products()

- Tool Protocol: POST /tools/execute
  {
    "tool_name": "search_products",
    "parameters": {
      "query": "string",
      "filters": {},
      "limit": 10
    }
  }

REQUEST PROCESSING FLOW:
------------------------
Step 1: Query Normalization
  - Correct typos (e.g., "gmaing" -> "gaming")
  - Expand synonyms (e.g., "PC" -> "personal computer", "desktop")
  - Input: "gaming PC under $2000"
  - Output: "gaming personal computer under 2000 dollars"

Step 2: Query Parsing
  - Extract filters from natural language
  - Example: "gaming PC under $2000" ->
    {
      "product_type": "desktop_pc",
      "price_max_cents": 200000,
      "use_case": "Gaming"
    }
  - Merge with explicit filters from request

Step 3: Domain Detection
  - Detect domain from query + filters:
    * Vehicles: "car", "vehicle", "SUV", etc.
    * Laptops: "laptop", "notebook", "computer"
    * Books: "book", "novel", "textbook"
    * Electronics: "gaming PC", "desktop", "components"
  - Routing decision:
    * Vehicles -> IDSS backend (port 8000)
    * Laptops/Books -> IDSS backend (interview) -> PostgreSQL + IDSS ranking
    * Electronics -> PostgreSQL + Neo4j KG + Vector search

Step 4: Data Source Queries (for Electronics)
  a) Neo4j Knowledge Graph
     - Query compatibility relationships
     - Match use cases (Gaming, VideoEditing, Work)
     - Find compatible components (CPU-GPU-RAM)
     - Return candidate product_ids
  
  b) PostgreSQL Database
     - Query products table with filters
     - Join with prices, inventory
     - Hard filters: product_type, gpu_vendor, price_max_cents
     - Soft filters: brand, color (can be relaxed)
  
  c) Redis Cache
     - Check cached search results
     - Cache prices, inventory for products
  
  d) Vector Search (if enabled)
     - Encode query: "gaming PC under $2000"
     - Find similar products via embeddings
     - Semantic similarity scoring

Step 5: IDSS Ranking (if applicable)
  - For Laptops/Books: Apply IDSS ranking algorithms
  - Methods:
    * embedding_similarity: Dense embeddings + MMR diversification
    * coverage_risk: Coverage-risk optimization
  - Input: PostgreSQL products + IDSS preferences
  - Output: Ranked product list

Step 6: Diversification
  - Entropy-based bucketing
  - Group products by diversification dimension (price, brand, etc.)
  - Create 2D grid: [rows][items]
  - Labels: ["Budget-Friendly", "Mid-Range", "Premium"]

Step 7: Build SearchResultsData
  - Convert to ProductSummary objects
  - Add provenance info (source, timestamp)
  - Apply limit and pagination

Step 8: Build MCP Response Envelope
  - status: ResponseStatus enum
  - data: SearchResultsData (products, total_count, next_cursor)
  - constraints: List[ConstraintDetail] (if interview question needed)
  - trace: RequestTrace (timings, sources, cache_hit)
  - version: VersionInfo

DATA SOURCES (Priority Order):
-------------------------------
1. Neo4j KG (compatibility, relationships, use cases)
2. PostgreSQL (authoritative product data)
3. Redis (cached results, prices, inventory)
4. Vector search (semantic similarity)
5. IDSS backend (ranking algorithms, for laptops/books)

RESPONSE FORMAT:
----------------
{
  "status": "OK" | "INVALID" | "FOLLOWUP_QUESTION_REQUIRED",
  "data": {
    "products": [
      {
        "product_id": "string",
        "name": "string",
        "price_cents": 0,
        "category": "string",
        "brand": "string"
      }
    ],
    "total_count": 0,
    "next_cursor": "string" | null
  },
  "constraints": [
    {
      "code": "FOLLOWUP_QUESTION_REQUIRED",
      "message": "What will you use the laptop for?",
      "details": {
        "question": "string",
        "quick_replies": ["string"],
        "response_type": "question"
      }
    }
  ],
  "trace": {
    "request_id": "uuid",
    "cache_hit": true/false,
    "timings_ms": {
      "parse_ms": 0.0,
      "kg_ms": 0.0,
      "db_ms": 0.0,
      "vector_ms": 0.0,
      "idss_ranking_ms": 0.0,
      "total": 0.0
    },
    "sources": ["neo4j", "postgres", "redis", "vector"]
  },
  "version": {
    "catalog_version": "string",
    "updated_at": "ISO datetime"
  }
}

================================================================================
3. GAMING PC EXAMPLE: COMPATIBILITY AND EFFICIENCY
================================================================================

QUERY: "optimizing the selection of components for a gaming PC under $2,000"

PROCESSING:
-----------
1. Query Normalization:
   - "gaming PC" -> "gaming personal computer"
   - "$2,000" -> "2000 dollars"

2. Query Parsing:
   - Extracted filters:
     {
       "category": "Electronics",
       "product_type": "desktop_pc",
       "price_max_cents": 200000,
       "use_case": "Gaming"
     }

3. Domain Detection:
   - Detected: Electronics
   - Routing: PostgreSQL + Neo4j KG + Vector search

4. Neo4j KG Query:
   - Match products with USE_CASE relationship to "Gaming"
   - Check compatibility:
     * CPU-GPU compatibility
     * RAM compatibility
     * Power supply requirements
   - Return compatible product_ids

5. PostgreSQL Query:
   - Filter: category='Electronics', product_type='desktop_pc', price_cents <= 200000
   - Join with prices, inventory
   - Hard filter: gpu_vendor='NVIDIA' (for gaming)
   - Return matching products

6. Compatibility Verification:
   - Check CPU-GPU compatibility (from Neo4j)
   - Verify power supply requirements
   - Check RAM compatibility
   - Filter incompatible combinations

7. Ranking:
   - Price-performance ratio
   - Gaming performance score
   - Efficiency metrics
   - Sort by best value

8. Response:
   - Return top 10 gaming PCs under $2000
   - Include compatibility information
   - Show price-performance metrics

================================================================================
4. DATA CONSISTENCY ACROSS STORES
================================================================================

POSTGRESQL (Authoritative Source):
----------------------------------
- products table: product_id, name, description, category, brand, etc.
- prices table: product_id, price_cents, currency
- inventory table: product_id, available_qty
- Relationships: products.price_info, products.inventory_info

REDIS (Cache Layer):
--------------------
- Keys: mcp:prod_summary:{product_id}, mcp:price:{product_id}, mcp:inventory:{product_id}
- TTL: 5 min (summary), 1 min (price), 30 sec (inventory)
- Pattern: Cache-aside (read-through, write-through on miss)
- Never authoritative, always refreshable from PostgreSQL

NEO4J (Knowledge Graph):
------------------------
- Nodes: Product, UseCase, Component, Brand
- Relationships: USE_CASE, COMPATIBLE_WITH, ALTERNATIVE_TO, BUNDLE
- Properties: product_id, name, category, price_cents, use_case, compatibility
- Sync: Populated from PostgreSQL via populate_kg_electronics.py script

DATA SYNC STRATEGY:
-------------------
1. PostgreSQL is authoritative (source of truth)
2. Redis is cache (TTL-based expiration)
3. Neo4j is derived (populated from PostgreSQL)
4. Sync frequency:
   - Redis: Real-time (on cache miss)
   - Neo4j: Periodic (via script, e.g., daily)

VERIFICATION:
------------
- All products in PostgreSQL should have:
  * Corresponding price entry
  * Corresponding inventory entry
  * Optional: Neo4j node (if Electronics category)
- Redis cache should match PostgreSQL (within TTL)
- Neo4j should have relationships for Electronics products

================================================================================
5. CHANGES MADE
================================================================================

1. Enhanced Logging in get_product():
   - Added protocol mapping logs (MCP/UCP/Tool)
   - Added step-by-step processing logs
   - Added cache hit/miss logging
   - Added timing breakdown logs
   - Added data source tracking

2. Enhanced Logging in search_products():
   - Added protocol mapping logs
   - Added query normalization logs
   - Added query parsing logs
   - Added domain detection logs
   - Added routing decision logs
   - Added data source query logs

3. Created Test Script:
   - test_gaming_pc_example.py
   - Tests MCP protocol
   - Tests UCP protocol
   - Tests get_product endpoint
   - Tests IDSS interview flow

4. Documentation:
   - This file (API_PROTOCOL_DOCUMENTATION.txt)
   - Detailed request processing flow
   - Protocol mapping
   - Data source priority
   - Response format

5. Data Consistency:
   - Verified PostgreSQL schema
   - Verified Redis cache keys
   - Verified Neo4j sync script
   - Added verification checks

================================================================================
6. TESTING THE GAMING PC EXAMPLE
================================================================================

Run the test script:
  python mcp-server/test_gaming_pc_example.py

Expected output:
  - MCP protocol search results
  - UCP protocol search results
  - Product details
  - IDSS interview flow
  - Trace information showing data sources

Verify:
  - Products are under $2000
  - Products are gaming-compatible
  - Compatibility information is accurate
  - All data sources are queried correctly

================================================================================
7. LATENCY METRICS
================================================================================

BENCHMARK RESULTS:
------------------
Run benchmark script:
  python mcp-server/scripts/benchmark_latency.py

Expected Latency (typical):
  - get_product (cache hit): < 50ms
  - get_product (cache miss): < 200ms
  - search_products (simple): < 500ms
  - search_products (complex with IDSS): < 2000ms
  - add_to_cart: < 100ms

Protocol Overhead:
  - MCP Protocol: ~10-20ms
  - UCP Protocol: ~15-25ms (slight overhead from conversion)
  - Tool Protocol: ~10-20ms

LATENCY BREAKDOWN (get_product):
---------------------------------
- Cache lookup: 1-5ms (Redis)
- PostgreSQL query: 10-50ms (if cache miss)
- Response building: 1-5ms
- Total (cache hit): 5-20ms
- Total (cache miss): 50-200ms

LATENCY BREAKDOWN (search_products):
-------------------------------------
- Query normalization: 1-5ms
- Query parsing: 5-20ms
- Domain detection: 1-5ms
- Neo4j KG query: 50-200ms (if enabled)
- PostgreSQL query: 20-100ms
- Vector search: 50-300ms (if enabled)
- IDSS ranking: 100-500ms (if applicable)
- Diversification: 10-50ms
- Response building: 5-20ms
- Total (simple): 100-500ms
- Total (complex with IDSS): 500-2000ms

OPTIMIZATION TARGETS:
---------------------
- get_product: < 100ms (p95)
- search_products: < 1000ms (p95)
- Cache hit rate: > 80% (for get_product)

================================================================================
8. IDSS RECOMMENDATION SYSTEM INTEGRATION
================================================================================

MCP USES IDSS BACKEND FOR RECOMMENDATIONS:
------------------------------------------
✅ CONFIRMED: MCP routes laptops/books through IDSS backend for:
  1. Interview system (same complex questioning as vehicles)
  2. Semantic parsing (extract filters and preferences)
  3. Recommendation algorithms:
     - embedding_similarity: Dense embeddings + MMR diversification
     - coverage_risk: Coverage-risk optimization
  4. Diversification: Entropy-based bucketing

HARD CONSTRAINTS (Explicit Filters):
------------------------------------
For Vehicles:
  - brand: List[str] (e.g., ["Toyota", "Honda"])
  - model: List[str] (e.g., ["Camry", "Civic"])
  - price_max: int (dollars)
  - body_style: List[str] (e.g., ["SUV", "Sedan"])
  - year: str (e.g., "2020", "2018-2022")

For Electronics/Laptops:
  - brand: List[str] (e.g., ["Apple", "Dell"]) - HARD CONSTRAINT
  - product_type: List[str] (e.g., ["gaming_laptop", "laptop"]) - HARD CONSTRAINT
  - gpu_vendor: List[str] (e.g., ["NVIDIA", "AMD"]) - HARD CONSTRAINT
  - cpu_vendor: List[str] (e.g., ["Intel", "AMD"]) - HARD CONSTRAINT
  - price_max_cents: int (cents) - HARD CONSTRAINT
  - category: str (e.g., "Electronics") - HARD CONSTRAINT

SOFT CONSTRAINTS (Implicit Preferences):
----------------------------------------
For Vehicles:
  - use_case: str (e.g., "daily commute", "family trips", "luxury")
  - liked_features: List[str] (e.g., ["fuel efficiency", "safety", "luxury"])
  - disliked_features: List[str] (e.g., ["poor visibility"])
  - Notes: str (free text describing preferences)

For Electronics/Laptops:
  - use_case: str (e.g., "Gaming", "Work", "School", "Creative") - SOFT CONSTRAINT
  - liked_features: List[str] (e.g., ["high performance", "portable", "long battery", "luxury", "premium"]) - SOFT CONSTRAINT
  - disliked_features: List[str] (e.g., ["heavy", "poor battery", "slow"]) - SOFT CONSTRAINT
  - Notes: str (free text describing preferences, e.g., "luxury laptop for work") - SOFT CONSTRAINT

SOFT CONSTRAINT EXAMPLES FOR LAPTOPS:
--------------------------------------
- "luxury laptop" → liked_features=["luxury", "premium"]
- "portable laptop for work" → use_case="Work", liked_features=["portable"]
- "gaming laptop but not too heavy" → use_case="Gaming", disliked_features=["heavy"]
- "family safe laptop" → liked_features=["family safe", "reliable"]

HOW SOFT CONSTRAINTS WORK:
--------------------------
1. User says: "I want a luxury laptop for work"
2. Semantic parser extracts:
   - Explicit filters: category="Electronics"
   - Implicit preferences: liked_features=["luxury"], use_case="Work"
3. IDSS ranking uses:
   - Hard constraints: Filter products by category
   - Soft constraints: Boost products matching "luxury" and "Work" use case
4. Result: Products ranked by alignment with soft constraints

DIVERSIFICATION:
----------------
- Uses entropy-based bucketing
- Groups products by diversification dimension (price, brand, etc.)
- Creates 2D grid: [rows][items]
- Labels: ["Budget-Friendly", "Mid-Range", "Premium"]

SEMANTIC SIMILARITY:
--------------------
- Uses dense embeddings (all-mpnet-base-v2)
- Encodes query: "gaming laptop under $2000"
- Finds similar products via vector search
- Combines with hard/soft constraints for final ranking

================================================================================
9. ADD PRODUCT CAPABILITY DEMONSTRATION
================================================================================

"ADD THIS PRODUCT" WORKFLOW:
-----------------------------
This demonstrates how the AI agent can add a specific product to cart.

EXAMPLE USE CASE:
-----------------
User: "I want to add the Gaming Laptop RTX 4060 to my cart"

Step 1: AI Agent searches for product
  POST /api/search-products
  Request: {
    "query": "Gaming Laptop RTX 4060",
    "filters": {"category": "Electronics"},
    "limit": 5
  }
  Response: {
    "status": "OK",
    "data": {
      "products": [
        {
          "product_id": "laptop-001",
          "name": "Gaming Laptop RTX 4060",
          "price_cents": 149999,
          "category": "Electronics",
          "brand": "GamingBrand"
        }
      ],
      "total_count": 1
    },
    "trace": {
      "request_id": "req-001",
      "sources": ["postgres", "redis"],
      "timings_ms": {"total": 125.3}
    }
  }

Step 2: AI Agent gets product details (optional, for verification)
  POST /api/get-product
  Request: {
    "product_id": "laptop-001"
  }
  Response: {
    "status": "OK",
    "data": {
      "product_id": "laptop-001",
      "name": "Gaming Laptop RTX 4060",
      "description": "High-performance gaming laptop...",
      "price_cents": 149999,
      "available_qty": 5,
      "category": "Electronics"
    },
    "trace": {
      "request_id": "req-002",
      "cache_hit": true,
      "timings_ms": {"total": 12.5}
    }
  }

Step 3: AI Agent generates add_to_cart request
  POST /api/add-to-cart
  Request: {
    "cart_id": "user-cart-123",
    "product_id": "laptop-001",  # CRITICAL: Uses product_id, never product name
    "qty": 1
  }
  Response: {
    "status": "OK",
    "data": {
      "cart_id": "user-cart-123",
      "items": [
        {
          "product_id": "laptop-001",
          "name": "Gaming Laptop RTX 4060",
          "qty": 1,
          "price_cents": 149999,
          "subtotal_cents": 149999
        }
      ],
      "total_cents": 149999,
      "item_count": 1
    },
    "trace": {
      "request_id": "req-003",
      "cache_hit": false,
      "timings_ms": {"total": 45.2}
    }
  }

Step 4: AI Agent communicates response to user
  "I've added Gaming Laptop RTX 4060 to your cart. Total: $1,499.99"

HOW REQUEST IS GENERATED PER MCP:
----------------------------------
The AI agent follows this process:

1. User intent: "add Gaming Laptop RTX 4060"
2. Agent calls search_products to find product
3. Agent extracts product_id from search results
4. Agent calls add_to_cart with product_id (IDs-only rule)
5. Agent formats response for user

PROTOCOL MAPPING FOR ADD_TO_CART:
----------------------------------
- MCP Protocol: POST /api/add-to-cart
  Request Schema: AddToCartRequest
  {
    "cart_id": "string (required)",
    "product_id": "string (required, from search/get results)",
    "qty": int (required, >= 1)
  }

- UCP Protocol: POST /ucp/add_to_cart
  Request Schema: UCPAddToCartRequest
  Maps to: AddToCartRequest
  Conversion: ucp_add_to_cart() -> add_to_cart()

- Tool Protocol: POST /tools/execute
  {
    "tool_name": "add_to_cart",
    "parameters": {
      "cart_id": "string",
      "product_id": "string",
      "qty": int
    }
  }

HOW RESPONSE IS COMMUNICATED TO AI AGENT:
------------------------------------------
The MCP response includes:

1. Status: "OK" (success) or "OUT_OF_STOCK" / "NOT_FOUND" (error)
2. Cart data: Updated cart with items and total
3. Constraints: Error details if failed (e.g., "Product out of stock")
4. Trace: Request ID, timing, cache status
5. Version: Catalog version for staleness detection

AI Agent uses this to:
- Confirm success to user
- Handle errors gracefully
- Track cart state
- Detect stale data

LATENCY FOR ADD_TO_CART:
------------------------
- Average: < 100ms
- P95: < 200ms
- P99: < 500ms
- Breakdown:
  * Product lookup: 10-50ms
  * Inventory check: 5-20ms
  * Cart update: 10-30ms
  * Response building: 1-5ms

================================================================================
10. UNIT TESTS
================================================================================

TESTS OVERVIEW (QUICK REFERENCE)
-------------------------------
- Script: mcp-server/test_gaming_pc_example.py
  * Validates MCP + UCP protocol mapping
  * Exercises get_product and IDSS interview flow
- Unit tests: pytest mcp-server/tests/test_mcp_pipeline.py -v
  * get_product + search_products (MCP/UCP/Tool)
  * IDSS integration + hard/soft constraints
  * Latency metrics + add-to-cart workflow

Run unit tests:
  pytest mcp-server/tests/test_mcp_pipeline.py -v

Test Coverage:
  - get_product (MCP, UCP, Tool protocols)
  - search_products (MCP, UCP, Tool protocols)
  - IDSS integration
  - Hard/soft constraints
  - Latency metrics
  - Add to cart workflow

================================================================================
END OF DOCUMENTATION
================================================================================
